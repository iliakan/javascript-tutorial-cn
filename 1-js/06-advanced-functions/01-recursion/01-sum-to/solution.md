使用循环的解法:

```js run
function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
```

使用递归的解法:

```js run
function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
```

使用右边公式的解法: `sumTo(n) = n*(n+1)/2`:

```js run
function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
```

附注：使用公式的解法显然是最快的，针对任何数字，它都只需要三个运算；关键时刻还是数学有用啊！

以速度论，使用循环变量的方法第二快。无论是使用递归方法还是使用循环的方法，我们都要累加相同的数字，但递归方法需要嵌套调用并需要在执行中管理堆栈，这些都需要额外的资源，因此慢些。

又注：标准中关于“尾部调用”优化的描述是如果递归调用发生在函数的最后（如同上面的`sumTo`），那么外部调用函数就不用记忆执行的上下文背景，因为在调用返回后没有需要继续执行的代码。在这种情况下，即便是`sumTo(100000)`也不是什么问题。但如果你的JavaScript引擎不支持这样的优化，那么因为通常的引擎对堆栈的总数有限制，你会遇到“超过最大堆栈尺寸”的错误。
