  # 运算符

我们在学校学过很多运算符，例如加号`+`，乘号`*`，减号`-`等等。

在本章中，我们将重点放在学校算术未涉及的部分。
[cut]

## 术语: "一元", "二元", "操作数"

在我们继续学习之前，先来了解一些通用术语。

- *操作数* -- 是运算的对象。例如在 `5 * 2`这个乘法运算中就有2个操作数:左操作数 
`5`, 和右操作数`2`。有时也会把操作数称为参数。
- 一个运算符如果只有一个操作数则为一元运算符。例如一元减法`-`可以反转一个数字的正负：

    ```js run
    let x = 1;

    *!*
    x = -x;
    */!*
    alert( x ); // -1, unary minus was applied
    ```
- 一个运算符如果有两个操作数则为二元运算符，例如减号：

    ```js run no-beautify
    let x = 1, y = 3;
    alert( y - x ); // 2, binary minus substracts values
    ```
    
    形式上，这里我们讨论的是两个不同的运算符(虽然它们符号相同)：一元减法(只有一个操作数，反转它的符号)和二元运算符减号(两个操作数，作减法)。

## 使用二元加号`+`连接字符串

现在让我们来看看JavaScript运算符的特别功能，和学校所学的不太一样。

通常我们使用`+`对两个数字进行加法运算。

但如果`+`应用于两个字符串，则会合并它们(连接)：

```js
let s = "my" + "string";
alert(s); // mystring
```

注意，如果有任意一个操作数是字符串，那么另外一个操作数也会转换成字符串

例如:

```js run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

看到了吗，第一个操作数和第二个操作数谁是字符串并不重要。规则很简单：如果任一操作数是一个字符串，则将另一个操作数转换为一个字符串。

但是要注意一点，运算操作是从左往右的(满足数学运算法则)，如果在两个数字后面跟着一个字符串，那么这两个数字会先相加然后再转换为字符串：

```js
alert(2 + 2 + '1'); //"41" and not "221"
```

字符串的连接和转换是二元加号`+`的特别功能。其他算术运算符只会对数字起作用。它们总会把操作数转化为数字。

例如减法和除法：

```js run
alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3
```

##使用一元加号`+`进行数字转换

加号`+`存在两种形态，上面我们使用的二元形态和下面的一元形态。

一元形态的加号，或者说是加号运算符`+`应用于一个操作数的时候，不会对这个操作数做任何操作，但如果这个操作数不是一个数字，那么就会把它转换为数字。

例如:

```js run
// No effect on numbers
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*注意
// 转换了一个非数字
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

这和使用`Number(..)`的结果是一致的，但更简洁。

将字符串转换为数字的需求是很常见的。假设我们从HTML输入域获取到的一些值，这些值一般都是字符串。

这个时候如果我们将这些值相加，会怎样？

二元加号会把它们连接成一个字符串：

```js run
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", the binary plus concatenates strings
```

如果想把它们当作一个数字对待，那我们可以先进行转换然后再相加：

```js run
let apples = "2";
let oranges = "3";

*!*
// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5
*/!*

// the longer variant
// alert( Number(apples) + Number(oranges) ); // 5
```

对于一个数学家而言，这样的行为似乎有点奇怪。但从一个程序员的角度来看，这并没有什么特别：一元加号首先将字符串转换为数字，然后二元加号将它们加起来。

为什么一元加号的操作先于二元加号？这就是下面要说的，它们之间存在优先级。

## 运算符的优先级

如果一个表达式有超过一个运算符，那么执行顺序由它们的优先级来决定，换句话说，运算符之间存在隐式的优先级。

我们都知道，表达式`1 + 2 * 2`中的乘法应该在加法之前计算。这正是一种优先关系。乘法比加法有更高的优先级。

圆括号会覆盖所有优先级(即圆括号拥有最高优先级)，因此如果我们对现在的执行顺序不满意，我们可以使用圆括号来改变它，像这样：`(1 + 2) * 2`。

在JavaScript中有许多的运算符，每一个运算符都有一个与之对应的优先度，优先度较大的运算符先执行。如果两个运算符优先度相等，则从左往右执行。

这是一个优先度表[precedence table](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence)
(你不需要记住所有的优先度，但是要注意一点，一元运算符的优先度高于其二元形态):

| Precedence | Name | Sign |
|------------|------|------|
| ... | ... | ... |
| 15 | unary plus | `+` |
| 15 | unary minus | `-` |
| 14 | multiplication | `*` |
| 14 | division | `/` |
| 13 | addition (binary) | `+` |
| 13 | subtraction | `-` |
| ... | ... | ... |
| 3 | assignment | `=` |
| ... | ... | ... |


如上表所示，一元加号(unary plus)的优先度是15，比"加法"(二元加号)的13要高。
这就是为什么表达式`"+apples + +oranges"`中的一元加号先执行，然后再做加法。

## 赋值

赋值`=`也是一个运算符，根据上面的优先度表所示，它的优先度是3。

这就是为什么当我们对一个变量进行赋值操作时，例如`x = 2 * 2 + 1`，会先进行计算，再进行赋值，把结果储存到变量中：

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

允许链式赋值：

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```


链式赋值的运算从右到左。首先最右边的表达式`2+2`先执行，然后赋值给左边的变量`c`，`b`，`a`。最终，所有的变量都会用到同一个值。

````smart header="赋值运算符`\"=\"`会返回一个值"

一个运算符总会返回一个值，这对于大多数的运算符如加号`+`和乘号`*`是显而易见，对于赋值运算符来说也是如此。

执行`x = value`意味着把`value`赋值给`x`*然后返回x*

这里有一个demo，在一个复杂的表达式里进行赋值操作：

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```

如例所示，`(a = b + 1)`的运算结果等于赋值给`a`的值（为3），然后和`3`作减法。

很有意思，不是吗？我们应该理解它是如何运行的，因为有时候我们会在很多第三方的库见到这种写法，但我们不应该这样写。这些小技巧并不会让代码变得清晰可读。（注：这样的写法会降低代码可读性）
````

## 取余 %

取余运算符`%`看起来像百分号，但是它和百分号并没有关系。

`a % b` 的结果等于`a`除以`b`所得余数。

例如：

```js run
alert( 5 % 2 ); // 1 is a remainder of 5 divided by 2
alert( 8 % 3 ); // 2 is a remainder of 8 divided by 3
alert( 6 % 3 ); // 0 is a remainder of 6 divided by 3
```

## 求幂 **

求幂运算符`**`是最近才添加到语言中的。

对于自然数`b`,`a ** b`的结果等于`a`与自身相乘`b`次。

例如:

```js run
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```

`a`和`b`不是整数，运算符也能正常运算，例如：

```js run
alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root, that's maths)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)
```

## 自增/自减

<!-- Can't use -- in title, because built-in parse turns it into – -->

加一和减一几乎是最经常进行数字操作。

因此有一些运算符可以专门做这样的事情：

- **自增** `++` 变量自增1:

    ```js run no-beautify
    let counter = 2;
    counter++;      // 作用与counter = counter + 1相同, 但更简洁
    alert( counter ); // 3
    ```
- **自减** `--` 变量自减1:

    ```js run no-beautify
    let counter = 2;
    counter--;      // 作用与counter = counter - 1相同, 但更简洁
    alert( counter ); // 1
    ```

```warn
自增/自减只能作用于一个变量，像这样`5++`直接作用在值上会抛出错误。
```

`++`和`--`可以放在变量前或变量后

- 当运算符放在变量后，称为后置形式，如：`counter++`。

- 当运算符放在变量前，称为前置形式，如：`++counter`。

示例的两种形式都只做了一件事：使变量`counter`增加一。

那么这两种形式之间有什么不一样吗？有的，但我们只有用到`++/--`的返回值时才能看到它们的不同之处。

如我们所知，所有的运算符都会返回一个值。自增/自减运算符也不例外，前置形式返回运算后的值，后置形式运算前的值

来看看这个例子：

```js run
let counter = 1;
let a = ++counter; // (*)

alert(a); // *!*2*/!*
```

带`(*)`处前置调用`++counter`，使变量`counter`自增并返回变量自增后的值（2），因此`alert`结果为2

现在来看看后置形式：

```js run
let counter = 1;
let a = counter++; // (*) changed ++counter to counter++

alert(a); // *!*1*/!*
```

带`(*)`处后置调用`counter++`，同样的使`counter`自增，但是却返回了自增前的值（1），因此`alter`结果为1

总结:

- 如果不使用自增/自减的运算结果，那么两种形式并没有什么不同：
    ```js run
    let counter = 0;
    counter++;
    ++counter;
    alert( counter ); // 2, the lines above did the same
    ```
- 如果我们要自增/自减一个值*同时*马上使用运算后的值，那么我们应该使用前置形式：
    ```js run
    let counter = 0;
    alert( ++counter ); // 1
    ```
- If we'd like to increment, but use the previous value, then we need the postfix form:
- 如果我们要自增/自减一个值但需要用到运算前的值，那么我们应该使用后置形式：
    ```js run
    let counter = 0;
    alert( counter++ ); // 0
    ```

````smart header="Increment/decrement among other operators"
`++/--`可以在表达式中使用，它们的优先级几乎大于所有算术运算符。

例如:

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

对比:

```js run
let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value
```

这些写法在技术上来说是允许的，但这样会使代码的可读性变差，一行代码做多件事并不好。

当我们在阅读代码时，快速的扫视很容易错过像`counter++`这样的操作，同时这也让增加一个变量的操作难以被发现。

因此推荐一行代码只做一件事的风格：

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

## 位运算符


位运算符将参数视为32位的整数并在其二进制表示上进行运算。

这些运算符不是JavaScript独有的，所有的编程语言都支持这些运算符。

下面列出了这些运算符：

- 按位与 ( `&` )
- 按位或 ( `|` )
- 按位异或 ( `^` )
- 按位非 ( `~` )
- 按位左移 ( `<<` )
- 按位右移 ( `>>` )
- 无符号右移 ( `>>>` )

这些运算符很少用到。为了理解它们，我们要需要深入到数字的底层表示，但现在不是做这些的好时候，因为我们不会马上需要用到它们，
如果你很好奇，可以在MDN上阅读这篇文章[Bitwise Operators](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)。
当你真的需要用到它们时候再深入研究它们，这样会更好。

## 就地修改

我们经常需要对一个变量进行运算，然后把运算后得到的新结果储存到这个变量里。

例如:

```js
let n = 2;
n = n + 5;
n = n * 2;
```

这些写法可以通过使用`+=`和`*=`这些运算符进行简化：

```js run
let n = 2;
n += 5; // now n=7 (same as n = n + 5)
n *= 2; // now n=14 (same as n = n * 2)

alert( n ); // 14
```

所有的算术运算符和位运算符都有这些简洁的"就地修改"形式：如`/=`, `-=`。

这些运算符和赋值运算符有着相同的优先度，因此它们会在所有的计算完成后执行：

```js run
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (right part evaluated first, same as n *= 8)
```

## 逗号

逗号运算符`,`是最不寻常的运算符。有时候它被用来书写更简短的代码，因此我们需要理解它是如何运行的。

逗号运算符允许我们执行几个表达式，并用逗号隔开它们。每一个表达式都会被执行，但只有最后一个会返回结果。

例如：

```js run
*!*
a = (1+2, 3+4);
*/!*

alert( a ); // 7 (the result of 3+4)
```


在这里，第一个表达式`1+2`执行了，但它的结果被丢弃，然后执行`3+4`并返回结果。

```smart header="逗号的优先度非常低"
逗号运算符的优先度非常低，低过`=`，因此例子中的圆括号是必须的。

如果没有圆括号：`a=1+2,3+4`会先执行加法`+`，把数字加起来，表达式变成`a=3,7`,然后执行赋值操作`a=3`，最后逗号后的数字`7`没有任何操作，因此被忽略掉。
```

为什么我们需要这样一个丢弃所有东西，只会返回最后一个结果的操作符呢？

有的时候可以在一些复杂的结构里使用它，把几个操作合在一行

例如：

```js
// three operations in one line
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

这样的小技巧在许多JavaScript的框架中都有用到，这也是为什么我们要提及它。但是这些小技巧并不会提高代码的可读性，因此我们在使用它们之前要好好想清楚。